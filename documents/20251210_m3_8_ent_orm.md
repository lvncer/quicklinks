# M3.8: Go API ent 導入の流れ（quicklinks）

このドキュメントは、マイルストーン **M3.8: Go API の ORM 導入（ent）** で実施した・および今後同様に行うとよい作業の「ざっくりした流れ」をまとめたものです。

細かい ent の使い方というより、**このリポジトリでどう ent を組み込んだか** にフォーカスしています。

## 1. 目的（M3.8 でやりたかったこと）

- Go API の DB アクセスを **手書き SQL + pgx だけの世界から、ent ベース** に寄せていくための土台づくり。
- まずは **`links` テーブルだけ ent 化** し、将来的に他のテーブルも順次 ent に寄せていく前提。
- スキーマ定義・マイグレーション・コード生成を **ent を中心に一元管理できる状態** に近づけること。
- すでに本番 Supabase に存在するテーブルは壊さず、
  - 本番 DB は **baseline（初期状態）として扱い**
  - 以降のスキーマ変更を ent 側で管理していく準備をすること。

## 2. ブランチとドキュメント

1. **ブランチ作成**

   - `main` から作業ブランチを作成：
     - ブランチ名: `feat/m3-8-ent-orm`

2. **マイルストーンドキュメントの更新**
   - ファイル: `documents/milestones.md`
   - セクション: `## M3.8: Go API の ORM 導入（ent）`
   - 主に以下を明文化：
     - まずは `links` テーブルのみ ent 化し、将来的に他テーブルも寄せていくこと。
     - `model.Link` は **外部向け DTO** として残し、永続化は ent のエンティティを使うこと。
     - 既存の Supabase 本番 DB は **`infra/migrations` に基づいて構築済みの baseline** とみなすこと。
     - 今後のスキーマ変更（例: `deleted_at` 追加）は **ent のマイグレーションを唯一のソース** とし、`infra/migrations` は段階的に廃止していくこと。
     - アプリ起動時に自動でマイグレーションは走らせず、**専用コマンドで手動実行する運用** にすること。

この段階ではまだコードには触らず、「M3.8 でやりたいこと」を文章で固定しました。

## 3. ent の導入とスキーマ定義

### 3-1. 依存追加

- ファイル: `api/go.mod`
- 追加した主な依存：
  - `entgo.io/ent v0.13.1`

### 3-2. コード生成のエントリポイント

- ファイル: `api/ent/generate.go`
- 役割: `go generate ./ent` を実行したときに、`ent/schema` を元にコードを生成するためのフック。

### 3-3. `links` テーブルの ent スキーマ

- ファイル: `api/ent/schema/link.go`
- 目的: 既存の `links` テーブル（Supabase / Postgres）の構造を ent のスキーマとして表現する。
- 主なフィールド（概念レベル）：
  - `id` (UUID, PK)
  - `user_id` (string, nullable)
  - `url` (string, 必須)
  - `title`, `description`, `domain`, `og_image`, `page_url`, `note` (string, nullable)
  - `tags` (string のスライス)
  - `metadata` (JSONB, デフォルト `{}`)
  - `saved_at`, `created_at` (time, デフォルト `now()` 相当)
  - `published_at` (\*time.Time, nullable)
- Index 定義（シンプルな形）：
  - `(user_id, saved_at)`
  - `(domain)`
  - `(published_at)`

### 3-4. コード生成

- コマンド（`api` ディレクトリにて）：
  - `go mod download entgo.io/ent`
  - `go get entgo.io/ent/cmd/ent@v0.13.1`
  - `go generate ./ent`
- 結果：
  - `api/ent` 配下に ent のクライアント・エンティティ・クエリビルダ等のコードが生成される。
  - まだこの時点では **ハンドラやサービス層から ent は呼ばれていない** 状態。

## 4. ent クライアントの初期化（internal/db）

### 4-1. ent クライアント作成関数

- ファイル: `api/internal/db/ent.go`
- 追加内容（概念）：
  - 関数: `NewEntClient(dsn string) (*ent.Client, error)`
  - やっていること：
    1. `sql.Open("pgx", dsn)` で `*sql.DB` を開く（pgx の database/sql ラッパーを使用）。
    2. `entsql.OpenDB(dialect.Postgres, db)` で ent 用の Driver を作成。
    3. `ent.NewClient(ent.Driver(drv))` で `*ent.Client` を返す。
  - **ここではマイグレーションは一切実行しない**（スキーマ変更は別コマンドで行う前提）。

## 5. リポジトリ層と DTO ↔ ent mapper

### 5-1. LinkRepository の新設

- ファイル: `api/internal/repository/link_repository.go`
- 目的: ハンドラから直接 ent を触らず、**インターフェース越しにリンク操作を行うための層** を作る。

- 主な要素：
  - インターフェース `LinkRepository`：
    - `CreateLink(ctx, input) (string, error)`
    - `ListLinks(ctx, userID string, limit int) ([]model.Link, error)`
  - 入力 DTO `CreateLinkInput`：
    - `UserID`, `URL`, `Title`, `Description`, `Domain`, `OGImage`, `PageURL`, `Note`, `Tags`, `PublishedAt` など。
  - 実装 `entLinkRepository`：
    - `CreateLink`:
      - `client.Link.Create()` を使って ent エンティティを作成。
      - `Tags` が `nil` の場合は空スライスに変換して保存。
    - `ListLinks`:
      - `Where(user_id = ?)` を指定して、指定ユーザーのリンクを取得。
      - `published_at DESC, saved_at DESC` の順で並び替え。
      - `limit` を超えないように `Limit(limit)` を指定。

### 5-2. DTO ↔ ent の変換（mapper）

- ファイル: `api/internal/repository/mapper.go`
- 目的: **ent のエンティティ型と `model.Link` の変換を 1 箇所に閉じ込める** ためのヘルパー。

- 主な関数：
  - `entLinkToModel(l *ent.Link) model.Link`
    - ent の `Link` から `model.Link` を組み立てる。
    - ent 側で `Nillable` な string フィールド（`Title`, `Description`, `Domain`, `OgImage`, `PageURL`, `Note`, `UserID`）は、
      - `nil` の場合は `""` にして DTO に詰める（従来の `rows.Scan` と同じ挙動に合わせるため）。
  - `entLinksToModels([]*ent.Link) []model.Link`
    - 複数件をまとめて DTO に変換するためのヘルパー。

これにより、**handler / service 層は ent の型を直接意識せずに `model.Link` だけを扱う** 形になっています。

## 6. ハンドラのリファクタ（CreateLink / GetLinks）

### 6-1. 依存の差し替え

- ファイル: `api/internal/handler/links.go`
- 変更前：
  - `LinksHandler` が `*pgxpool.Pool` を直接持ち、生 SQL を発行していた。
- 変更後：
  - フィールド: `repo repository.LinkRepository`
  - コンストラクタ: `NewLinksHandler(repo repository.LinkRepository)`
  - ハンドラ側は **リポジトリ越しにリンク操作をするだけ** になった。

### 6-2. `CreateLink` の流れ

1. Middleware から `user_id` を取得（Clerk 認証済み前提）。
2. `LinkCreateRequest` を JSON バインド＆バリデーション。
3. URL のバリデーション＆ドメイン抽出。
4. `service.FetchMetadata` で OGP 情報を取得し、title/description/og_image/published_at を補完。
5. `context.WithTimeout` で 5 秒のタイムアウトを設定。
6. `repository.CreateLinkInput` を組み立てて `h.repo.CreateLink` を呼ぶ。
7. 返ってきた `id` を JSON で返却。

※ SQL 文は完全に削除され、永続化は ent のリポジトリ実装に任せています。

### 6-3. `GetLinks` の流れ

1. Middleware から `user_id` を取得。
2. クエリパラメータ `limit` をパース（1〜100 の範囲、デフォルト 50）。
3. `context.WithTimeout` で 5 秒のタイムアウトを設定。
4. `h.repo.ListLinks(ctx, userID, limit)` を呼んでリンク一覧を取得。
5. 返ってきた `[]model.Link` をそのまま JSON で `{"links": links}` として返却。

※ ここでも SQL は使わず、並び順や件数制御はリポジトリ（ent クエリ）側で行います。

## 7. サーバー初期化での ent 配線

- ファイル: `api/cmd/server/main.go`
- 変更点（概念）：
  1. 既存どおり `db.NewPool` で pgxpool を作成（他用途のために残している）。
  2. `db.NewEntClient(cfg.DatabaseURL)` を呼んで ent クライアントを作成。
     - エラー時は `log.Fatalf`。
     - 正常時は `defer entClient.Close()` でクローズを保証。
  3. `repository.NewLinkRepository(entClient)` で `LinkRepository` を生成。
  4. `handler.NewLinksHandler(linkRepo)` に渡してルーティングを登録。

これにより、アプリケーション起動時に

- pgx のコネクションプール
- ent クライアント

の両方が準備され、`/api/links` 系のハンドラは ent ベースのリポジトリを経由して DB にアクセスするようになりました。

## 8. 現時点での状態と今後

### 8-1. 現時点（M3.8 完了時点）の状態

- `links` テーブルに対する読み書きは **ent ベースのリポジトリ層経由** に切り替わっている。
- `model.Link` は引き続きレスポンス DTO として利用されている。
- ent のスキーマと生成コードは `api/ent` 配下に配置されている。
- DB スキーマ自体は **既存の `infra/migrations` によるもの** をそのまま利用しており、
  - ent は現状「既存テーブルに対する ORM クライアント」として動いている。

### 8-2. 今後やること（M3.8 後の世界）

- ent の `migrate` を使って、
  - 現在の `links` テーブルに相当する **初期マイグレーション** を ent 側に定義する。
  - 既存本番 DB を baseline と見なすための運用手順（"このバージョンまでは適用済み" という扱い）を決める。
- 将来のスキーマ変更（例: `links.deleted_at` の追加や index 調整）は、
  - ent のスキーマ変更 → ent migrate で SQL 生成 → Supabase に適用、という流れに寄せていく。
- `infra/migrations` ディレクトリは、
  - 完全に ent ベースに移行できたタイミングで、段階的に削除していく。

## 9. 開発者向けの簡単な手順サマリ

M3.8 以降、`links` 周りで開発するときのざっくり手順：

1. **スキーマを変えたいとき**

   - `api/ent/schema/link.go` を編集（フィールド追加など）。
   - `go generate ./ent` を実行してコードを再生成。
   - 必要に応じて ent のマイグレーションを定義し、手動で Supabase に適用する。

2. **永続化ロジックを変えたいとき**

   - `api/internal/repository/link_repository.go` を編集（クエリ条件や Order など）。
   - DTO との変換が必要なら `api/internal/repository/mapper.go` を更新。

3. **API の振る舞いを変えたいとき**
   - `api/internal/handler/links.go` を編集。
   - 基本的には `LinkRepository` の呼び出し方や、リクエスト/レスポンスの形を変える。

このドキュメントを読めば、「M3.8 で ent をどう組み込んだか」と「今後どこを触ればいいか」がひと通り追える想定です。
